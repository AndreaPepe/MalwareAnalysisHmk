#include <stdio.h>
#include <windows.h>
#include <winreg.h>

typedef struct struct_query_info struct_query_info;
typedef struct struct_subkey struct_subkey;
typedef struct struct_regValue struct_regValue;

struct struct_query_info{
	LPSTR className;
	DWORD classNameLen;
	DWORD numSubKeys;
	DWORD maxSubKeyLen;
	DWORD maxClassLen;
	DWORD numValues;
	DWORD maxValueNameLen;
	DWORD maxValueLen;
	DWORD securityDescriptor;
	FILETIME lastWriteTime;
	struct_subkey *listOfSubKeys;
	struct_regValue *listOfValues;
};

struct struct_subkey{
	struct_query_info *queryInfo;
	struct_subkey *next;
	LPSTR subKeyName;
	DWORD nameLen;
};

struct struct_regValue{
	struct_query_info *queryInfo;
	struct_regValue *next;
	CHAR valueName[16384];
	DWORD valueNameLen;
	DWORD type;
	BYTE data[256];
	DWORD dataLen;
};


DWORD global_int;

void fun1(){
	
	/*
	This function is also called by the entry function.
	In particular, the entry function calls fun1() before calling the main():
	this implies that, when the main calls fun1(), the value of the global variable
	"global_int" has already been set to 1.

	SO THIS FUNCTION DOES ABSOLUTELY NOTHING WHEN IT'S CALLED BY MAIN!!!
	
	Indeed, the only cross references to the variable "global_int" are made in the fun1() function.
	This means that global_int can be modified only by fun1(), so, after the first call to fun1(),
	global_int's value is always equal to 1!!!
	*/
	
	if(global_int != 0){
		return;
	}
	global_int = 1;
	// calls other stuff
	//fun2();
	return;
}

void funPrintResults(struct_query_info* info){
	printf("Class: %s\n",info->className);
	printf("Security descriptor: 0x%lx\n",info->securityDescriptor);
	printf("Time: %08lx%08lx\n",(info->lastWriteTime).dwLowDateTime, (info->lastWriteTime).dwHighDateTime);
	  
	// print subKeys names, if any
	struct_subkey* currSubKey = info->listOfSubKeys;
	if(currSubKey != NULL){
		puts("SubKeys:");
		do{
			printf("\t%s\n", currSubKey->subKeyName);
			currSubKey = currSubKey->next;
		} while(currSubKey != NULL);
	}
	  
	// print values, if any
	struct_regValue* currValue = info->listOfValues;
	if(currValue != NULL){
		puts("Values:");
		do{
			printf("\t%s: [%lu] ", currValue->valueName, currValue->type);
			// print data, if any
			if(currValue->dataLen != 0){
				int i;
				for(i=0; i < currValue->dataLen; i++){
					printf(" %02x", currValue->data[i]);
				}
			}
			printf(" (%s)\n", currValue->data);
			currValue = currValue->next;
		} while(currValue != NULL);
	}
	return;
}



struct_query_info* funRetrieveInfo(HKEY param1){
	struct_subkey* subkeys = NULL;
	struct_regValue* values = NULL;
	
	struct_query_info* info = malloc(sizeof(struct_query_info)); // 52 bytes
	if(info == NULL) goto malloc_failed;
	info -> className = malloc(260);
	if(info -> className == NULL) goto malloc_failed;
	*(info -> className) = '\0';
	info->classNameLen = 260;
	info->numSubKeys = 0;
	
	// getting info
	DWORD queryRes = RegQueryInfoKeyA(param1, info->className, &info->classNameLen, NULL, &info->numSubKeys, &info->maxSubKeyLen, &info->maxClassLen, &info->numValues, &info->maxValueNameLen, &info->maxValueLen, &info->securityDescriptor, &info->lastWriteTime);
	if(queryRes != ERROR_SUCCESS){
		puts ("RegQueryInfoKey failed: key not found");
		return NULL;
	}else{
		
		//retrieving subkeys and building the first linked list
		if(info->numSubKeys != 0){
			struct_subkey* next = NULL;	// last inserted subKey
			int i;
			for(i = 0; i < info -> numSubKeys; i++){
				subkeys = malloc(sizeof(struct_subkey));	// 16 bytes
				if(subkeys == NULL) goto malloc_failed;
				
				subkeys -> queryInfo = info;
				subkeys -> next = next;
				subkeys -> nameLen = info -> maxSubKeyLen;
				subkeys -> subKeyName = malloc(info->maxSubKeyLen);
				if(subkeys -> subKeyName == NULL) goto malloc_failed;
				// getting subkey info
				if(RegEnumKeyExA(param1, i, subkeys->subKeyName, &subkeys->nameLen, 
				NULL, NULL, NULL, &info->lastWriteTime) != ERROR_SUCCESS){
					// removing the item from the list: something went wrong
					
					next = subkeys->next;	//the head of the list remains the same
					free(subkeys);
					subkeys = next;			// the head of the list is the last inserted struct
				}else{
					next = subkeys;			// new head
				}
			}
		}
		info->listOfSubKeys = subkeys;
		
		//retrieving values and building the second linked list
		if(info->numValues != 0){
			struct_regValue* nextVal = NULL;
			int j;
			for(j=0; j < info->numValues; j++){
				values = malloc(sizeof(struct_regValue));	//16660 bytes
				if(values == NULL) goto malloc_failed;
				
				values->queryInfo = info;
				values->next = nextVal;
				values->valueNameLen = 16383;			// MAX POSSIBLE
				values->valueName[0] = '\0';
				values->dataLen = 256;
				
				if(RegEnumValueA(param1, j, values->valueName, &values->valueNameLen, NULL, 
				&values->type, &values->data, &values->dataLen) != ERROR_SUCCESS){
					nextVal = values->next;
					free(values);
				}
				nextVal = values;
			}
		}
		info->listOfValues = values;
		return info;
	}
	
malloc_failed:
	puts("Memory allocation error");
	exit(1);
}


struct_query_info* funCreateKey(HKEY hKey, LPCSTR subKey){
	struct_query_info* ret = NULL;
	HKEY newKey;
	if (RegOpenKeyExA(hKey, subKey, 0, KEY_ALL_ACCESS, &newKey) == ERROR_SUCCESS){
		ret = funRetrieveInfo(newKey);
		RegCloseKey(newKey);	// close the handle to the previuosly opened key
	}
	return ret;
}




int main(int argc, char **argv){
	// function that typically does nothing
	fun1();
	
	if(argv[argc] == '\0'){
		/*
		always true; maybe to avoid leaking of useful informations 
		for the reversing process by executing the program
		*/
		return 0;		
	}
	
	if(argc < 3){
		argv[1] = '\0';
		argv[2] = '\0';
	}
	
	HKEY hKey = atoi(argv[1]);
	if(hKey == 0){
		hKey = HKEY_LOCAL_MACHINE;
	}
	
	char* subKeyString = argv[2];
	if(argv[2] == '\0'){
		subKeyString = "SYSTEM\\ControlSet001\\Control";
	}
	
	struct_query_info* info = funCreateKey(hKey, subKeyString);
	int ret = 1;
	if(info != NULL){
		funPrintResults(info);
		ret = 0;
	}
	return ret;
}
