#include <stdlib.h>
struct struct_query_info{
	LPSTR className,
	DWORD classNameLen,
	DWORD numSubKeys,
	DWORD maxSubKeyLen,
	DWORD maxClassLen,
	DWORD numValues,
	DWORD maxValueNameLen,
	DWORD maxValueLen,
	DWORD securityDescriptor,
	FILETIME lastWriteTime,
	struct_subkey *listOfSubKeys,
	struct_regValue *listOfValues
};

struct struct_subkey{
	struct_query_info *queryInfo,
	struct_subkey *next,
	LPSTR subKeyName,
	DWORD nameLen
};

struct struct_regValue{
	struct_query_info *queryInfo,
	struct_regValue *next,
	CHAR[16384] valueName,
	DWORD valueNameLen,
	DWORD type,
	BYTE[256] data,
	DWORD dataLen
};


struct_query_info* funRetrieveInfo(HKEY param1){
	struct_subkey* subkeys = NULL;
	struct_regValue* values = NULL;
	
	struct_query_info* info = malloc(sizeof(struct_query_info)); // 52 bytes
	if(info == NULL) goto malloc_failed;
	info -> className = malloc(260);
	if(info -> className == NULL) goto malloc_failed;
	*(info -> className) = '\0';
	info->classNameLen = 260;
	info->numSubKeys = 0;
	
	// getting info
	DWORD queryRes = RegQueryInfoKeyA(param1, info->className, &info->classNameLen, NULL, &info->numSubKeys, &info->maxSubKeyLen, &info->maxClassLen, &info->numValues, &info->maxValueNameLen, &info->maxValueLen, &info->securityDescriptor, &info->lastWriteTime);
	if(queryRes != ERROR_SUCCESS){
		puts ("RegQueryInfoKey failed: key not found");
		return NULL;
	}else{
		
		//retrieving subkeys and building the first linked list
		if(info->numSubKeys != 0){
			struct_subkey* next = NULL;	// last inserted subKey
			for(int i = 0; i < info -> numSubKeys; i++){
				subkeys = malloc(sizeof(struct_subkey));	// 16 bytes
				if(subkeys == NULL) goto malloc_failed;
				
				subkeys -> queryInfo = info;
				subkeys -> next = next;
				subkeys -> nameLen = info -> maxSubKeyLen;
				subkeys -> subKeyName = malloc(info->maxSubKeyLen);
				if(subkeys -> subKeyName == NULL) goto malloc_failed;
				// getting subkey info
				if(RegEnumKeyExA(param1, i, subkeys->subKeyName, &subkeys->nameLen, NULL, NULL, NULL, &info->lastWriteTime) != ERROR_SUCCESS){
					// removing the item from the list: something went wrong
					
					next = subkeys->next;	//the head of the list remains the same
					free(subkeys);
					subkeys = next;			// the head of the list is the last inserted struct
				}else{
					next = subkeys;			// new head
				}
			}
		}
		info->listOfSubKeys = subkeys;
		
		//retrieving values and building the second linked list
		if(info->numValues != 0){
			struct_regValue* nextVal = NULL;
			for(int j=0; j < info->numValues; j++){
				values = malloc(sizeof(struct_regValue));	//16660 bytes
				if(values == NULL) goto malloc_failed;
				
				values->queryInfo = info;
				values->next = nextVal;
				values->valueNameLen = 16383;			// MAX POSSIBLE
				values->valueName[0] = '\0';
				values->dataLen = 256;
				
				if(RegEnumValueA(param1, j, values->valueName, &values->valueNameLen, NULL, &values->type, &values->data, &values->dataLen) != ERROR_SUCCESS){
					nextVal = values->next;
					free(values);
				}
				nextVal = values;
			}
		}
		info->listOfValues = values;
		return info;
	}
	
malloc_failed:
	puts("Memory allocation error");
	exit(1);
}